O Node.js é ótimo para lidar com tarefas que não precisam ser executadas instantaneamente, como buscar dados em um site. O encadeamento de promessas ajuda a gerenciar essas tarefas em uma ordem específica, uma após a outra.

### O que é Promise Chaining?
O encadeamento de promessas no Node.js permite que você execute várias operações assíncronas em uma sequência, onde cada operação começa após a conclusão da anterior.

Execução sequencial: garante que tarefas assíncronas sejam executadas em uma ordem específica, com cada tarefa aguardando o resultado da anterior.
Tratamento de erros: fornece uma maneira limpa de lidar com erros em operações assíncronas, garantindo que quaisquer problemas sejam detectados e resolvidos.
Sintaxe
```node
promise
    .then(value => {
        return newValue;
    })
    .then(newValue => {
        return anotherValue;
    })
    .catch(error => {

    });
```
.then() manipula o resultado de uma promessa e pode retornar um novo valor ou promessa.
.catch() manipula erros que ocorrem na cadeia de promessas.

### Como funciona o encadeamento de promessas
Promessas são como marcadores de posição para algo que acontecerá mais tarde (como dados vindos de um servidor). O encadeamento permite que você decida o que fazer depois que algo acontecer.
Each .then()recebe o resultado da etapa anterior. Você pode usar esse resultado e passar algo novo para a próxima etapa.
Retornar um valor de .then() cria automaticamente uma nova promessa que carrega esse valor. Isso mantém a cadeia em funcionamento. Se você retornar uma promessa de .then(), a cadeia aguarda a conclusão dessa promessa antes de prosseguir.
O .catch() no final é como uma rede de segurança. Ele captura quaisquer erros que possam ter ocorrido em qualquer uma das etapas da cadeia.
![Funcionamento das Promessas](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20220113114155/Group-3.jpg)

Vamos agora entender a mudança de promessa com a ajuda de um exemplo
```node
const myPromise = new Promise((resolve, reject) => {
    setTimeout(() => { resolve(10); }, 500);
});

myPromise
    .then(value => {
        console.log("First then:", value);
        return value * 2;
    })
    .then(newValue => {
        console.log("Second then:", newValue);
        return newValue + 5;
    })
    .then(finalValue => {
        console.log("Final value:", finalValue);
    })
    .catch(error => { console.error("Error:", error); });
```

Saída
```
First then: 10
Second then: 20
Final value: 25
```
Uma nova Promise myPromise é criada, resolvendo com o valor 10 após um atraso de 500 ms.
O primeiro .then recebe o valor resolvido (10), registra-o e retorna o valor multiplicado por 2.
O segundo .then recebe o resultado do anterior .then (20), registra-o e retorna o valor mais 5.
O .then final recebe o resultado (25) e o registra. Este é o fim da cadeia.
O bloco .catch trataria de quaisquer erros que pudessem ter ocorrido na cadeia de promessas.

### Lidando com erros no encadeamento de promessas
O tratamento de erros é essencial em código assíncrono. O encadeamento de promessas fornece uma maneira limpa de gerenciar erros.
```node
const myPromise = new Promise((resolve, reject) => {
    setTimeout(() => { reject("Something went wrong!"); },
               500);
});

myPromise
    .then(
        value => { console.log("This won't be executed"); })
    .then(newValue => {
        console.log("This also won't be executed");
    })
    .catch(error => { console.error("Error:", error); });
```

Saída
```
Erro: Algo deu errado!
```
A promessa é rejeitada após 500 ms.
Os blocos .then são ignorados porque a promessa foi rejeitada.
O bloco .catch é executado, registrando a mensagem de erro.

### Encadeamento de Promessas vs. Async/Await
Enquanto o encadeamento de Promise melhora a legibilidade em comparação aos retornos de chamada, async/await oferece uma abordagem ainda mais síncrona.
Usando Async/Await (Código Equivalente)
```node
async function fetchDetail() {
    try {
        const user = await fetchData(1);
        console.log("User fetched:", user.name);

        const orders = await fetchOrders(user);
        console.log("Orders fetched:", orders);

        const processedOrder = await processOrder(orders[0]);
        console.log("Final Result:", processedOrder);
    } catch (error) {
        console.error("Error:", error);
    }
}

fetchDetail();
```

### Principais diferenças

|Recurso|Encadeamento de Promessas|Assíncrono/Aguardando|
|---|---|---|
|Legibilidade|Moderado|Melhorar|
|Tratamento de erros|`.catch()`|`try/catch`|
|Depuração|Mais difícil|Mais fácil|
|Complexidade de sintaxe|Mais alto|Mais baixo|


