O loop de eventos em Node.js é um mecanismo que permite que tarefas assíncronas sejam tratadas com eficiência sem bloquear a execução de outras operações. Ele:

Executa JavaScript de forma síncrona primeiro e depois processa operações assíncronas.
Delega tarefas pesadas como operações de E/S, temporizadores e solicitações de rede para a biblioteca libuv.
Garante a execução tranquila de diversas operações por meio do enfileiramento e agendamento de retornos de chamada de forma eficiente.

### Por que o Event Loop é importante?
O Event Loop é essencial no Node.js porque permite que operações assíncronas e não bloqueantes sejam manipuladas de forma eficiente, mesmo que o Node.js opere em um único thread.

Habilita a execução sem bloqueio, apesar do Node.js ser de thread única.
Ajuda a lidar com tarefas vinculadas a E/S de forma eficiente.
Torna o Node.js adequado para aplicativos escaláveis, como servidores web.

Vamos ver um exemplo assíncrono simples
```node
console.log("This is the first statement");

setTimeout(function() {
    console.log("This is the second statement");
}, 1000);

console.log("This is the third statement");
```

A primeira declaração é registrada imediatamente.
setTimeout agenda a segunda instrução para registrar após 1000 milissegundos.
A terceira declaração é registrada imediatamente depois.
Após 1000 milissegundos, o retorno de chamada de setTimeout é executado, registrando a segunda instrução.
Saída
```
Esta é a primeira afirmação
Esta é a terceira afirmação
Esta é a segunda afirmação
```

### Como funciona o loop de eventos?
Quando uma aplicação Node.js é executada, o loop de eventos é iniciado, processa primeiro o código síncrono e, em seguida, passa a lidar com tarefas assíncronas. A execução segue estas etapas:

### 1. Inicialização
Quando o Node.js é iniciado, ele carrega o script, executa o código síncrono e registra quaisquer tarefas assíncronas (por exemplo, temporizadores, solicitações de E/S, operações de rede).

### 2. Execução do script de entrada
A pilha de chamadas executa o código síncrono primeiro.
Todas as operações assíncronas (setTimeout, fs.readFile, solicitações de rede) são delegadas à libuv.

### 3. Lidando com operações assíncronas com libuv
O Node.js utiliza uma biblioteca C especial chamada libuv para lidar com operações assíncronas. Essa biblioteca gerencia um pool de threads que descarrega tarefas pesadas (como E/S de arquivos, operações de banco de dados ou solicitações de rede) que, de outra forma, bloqueariam o loop de eventos. O pool de threads contém diversas threads que executam tarefas como:

E/S do sistema de arquivos (fs.readFile)
Solicitações de rede (HTTP, TCP, DNS)
Temporizadores (setTimeout, setInterval)
Tarefas de compressão e criptografia

### 4. Execução de retorno de chamada
Assim que o pool de threads conclui suas tarefas, ele envia retornos de chamada para a fila de eventos. O loop de eventos processa esses retornos de chamada, mas somente quando a pilha de chamadas está vazia (ou seja, quando nenhum código síncrono está em execução).

### 5. Fases do Loop de Eventos
O loop de eventos passa por várias fases, cada uma projetada para lidar com um conjunto diferente de operações. Ele verifica eventos, lida com retornos de chamada assíncronos e executa tarefas na ordem correta.

### 6. Execução de retorno de chamada da fila de eventos
Após a pilha de chamadas estar vazia, o loop de eventos seleciona tarefas da fila de eventos e as envia para a pilha de chamadas para execução. Essas tarefas podem incluir:

Concluindo solicitações de rede
Processando eventos de E/S
Manipulando temporizadores como setTimeout ou setInterval
O diagrama a seguir é uma representação adequada do loop de eventos em um servidor Node.js: 
![Loop de Eventos Funcionando](https://media.geeksforgeeks.org/wp-content/uploads/20200224050909/nodejs2.png)


### Fases do loop de eventos
O loop de eventos em Node.js consiste em várias fases, cada uma das quais executa uma tarefa específica. Essas fases incluem:

![Fases do loop de eventos](https://media.geeksforgeeks.org/wp-content/uploads/20200224062607/phasesofloop-300x240.png)



### 1. Fase dos Temporizadores
Esta fase processa temporizadores que foram definidos usando setTimeout() e setInterval().
```node
console.log('Start');

setTimeout(() => {
    console.log('Timeout callback');
}, 2000);

console.log('End');
```
setTimeout() agenda um retorno de chamada para ser executado após 2000 milissegundos.
O loop de eventos processa esse retorno de chamada na fase de temporizadores após a execução do código síncrono.
Saída:
```
Começar
Fim
Retorno de chamada de tempo limite
```

### 2. Retornos de chamada pendentes
Esta fase executa retornos de chamada relacionados a E/S que foram adiados do ciclo de loop anterior.
```node
console.log('Start');

setImmediate(() => {
    console.log('Immediate callback');
});

console.log('End');
```
setImmediate() agenda um retorno de chamada para ser executado imediatamente após o ciclo de loop de eventos atual.
O loop de eventos processa esse retorno de chamada na fase de retornos de chamada pendentes.
Saída:
```
Começar
Fim
Retorno de chamada imediato
```

### 3. Ocioso, Preparar (somente para uso interno)
Esta fase é usada internamente pelo Node.js para tarefas em segundo plano.

### 4. Fase de votação (fase principal)
A fase de pesquisa executa a maioria das tarefas, como E/S, leitura de arquivos, solicitações HTTP e muito mais.
```node
const fs = require('fs');
const readStream = fs.createReadStream('./file.txt');

console.log('Start');

readStream.on('data', (chunk) => {
    console.log(chunk.toString());
});

console.log('End');
```
fs.readFile() inicia uma operação de leitura de arquivo assíncrona.
O retorno de chamada é adicionado à fase de pesquisa e executado assim que a leitura do arquivo for concluída.
Saída :
```
Começar
Fim
Leitura de arquivo concluída
```

### 5. Fase de verificação
Esta fase processa quaisquer retornos de chamada setImmediate() que foram adicionados à fila de mensagens.
```node
console.log('Start');

setImmediate(() => {
    console.log('Immediate callback');
});

console.log('End');
```
setImmediate() agenda um retorno de chamada para ser executado imediatamente após a fase de pesquisa.
O loop de eventos processa esse retorno de chamada na fase de verificação.
Saída
```
Começar
Fim
Retorno de chamada imediato
```

### 6. Fase de retorno de chamadas de fechamento
Esta fase executa retornos de chamada para conexões fechadas, como soquetes, fluxos e emissores de eventos.
```node
const net = require('net');
const server = net.createServer((socket) => {
    socket.on('close', () => {
        console.log('Socket closed');
    });
});

server.listen(8000);
```
O servidor escuta conexões de entrada.
Quando um soquete é fechado, o evento 'close' é emitido, e o retorno de chamada correspondente é executado na fase de retornos de chamada de fechamento.
Saída
```
Server listening on port 8000
```

### process.nextTick() e Promises no Loop de Eventos
Além dessas fases, há também process.nextTick() e o callback de promessa, que tem a maior prioridade no loop de eventos. Ele é executado após cada fase, antes de passar para a próxima.

Os retornos de chamada process.nextTick() são sempre executados antes que o loop de eventos passe para a próxima fase.
Os retornos de chamada de Promise resolvidos são processados imediatamente após process.nextTick().
Agora que você viu todas as fases, vamos entender a ordem usando este exemplo de código
```node
setImmediate(() => {
   console.log("setImmediate is called");
});

Promise.resolve("Promise is resolved").then(console.log);

setTimeout(() => {
   console.log("Time function is called");
}, 0);

process.nextTick(() => {
   console.log("Process.nextTick");
});
```

Saída
```
Process.nextTick 
Promise é resolvido 
A função Time é chamada 
setImmediate é chamado
```
Neste exemplo
process.nextTick() é executado antes de passar para a próxima fase.
Promessas resolvidas são executadas logo após process.nextTick().
setTimeout() é executado na fase de temporizadores.
setImmediate() é executado na fase de verificação.



