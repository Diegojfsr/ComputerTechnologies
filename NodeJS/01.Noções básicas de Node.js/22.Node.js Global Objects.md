No NodeJS, objetos globais são aqueles que podem ser acessados no aplicativo de qualquer lugar, sem usar explicitamente import ou require.

No JavaScript baseado em navegador, o objeto window é o escopo global, o que significa que ele contém todas as variáveis e funções globais.
No NodeJS, em vez do objeto window, o objeto global serve como escopo global, que contém todas as variáveis e funções globais do aplicativo. É assim que o NodeJS gerencia os recursos disponíveis em todo o aplicativo, assim como o Windows faz no navegador.

Explore a Referência Completa do Objeto Global NodeJS para obter explicações detalhadas, exemplos de uso e dicas de especialistas. Domine essas ferramentas essenciais para otimizar seu desenvolvimento NodeJS e gerenciar o ambiente da sua aplicação com eficiência.

### Objetos globais comumente usados em NodeJS
O NodeJS fornece um conjunto de objetos globais disponíveis em cada módulo. São objetos integrados que podem ser usados diretamente na aplicação. Vamos dar uma olhada em alguns dos objetos globais mais comumente usados no NodeJS.

### 1. global
O objeto global no NodeJS é equivalente ao objeto window nos navegadores. Qualquer variável ou função adicionada ao objeto global torna-se globalmente acessível em todo o aplicativo.
```node
global.a = 'This is a global variable';
console.log(a);  // Accessible from anywhere in the application
```
Saída
```
Esta é uma variável global
```

### 2. console
O objeto console é usado para imprimir mensagens na saída padrão (stdout) ou na saída de erro (stderr). Ele fornece métodos como console.log(), console.error() e console.warn() para registrar mensagens e depuração.
```node
console.log("This is a log message");
console.error("This is an error message");
```
Saída
![Captura de tela-2025-03-18-181853](https://media.geeksforgeeks.org/wp-content/uploads/20250318181911220947/Screenshot-2025-03-18-181853.png)

### 3. process
O objeto de processo no NodeJS fornece informações sobre o processo NodeJS em execução. Ele permite que você interaja com o sistema, obtenha detalhes sobre o processo e controle como ele é executado. Em termos simples, ele ajuda a gerenciar aspectos como configurações de ambiente, argumentos de linha de comando e como o aplicativo se comporta durante a execução.
```node
console.log("Process ID:", process.pid);
console.log("Node.js Version:", process.version);
```
Saída
```
Process ID: 32
Node.js Version: v16.20.1
```


### 4. Buffer
A classe Buffer é usada para lidar com dados binários em NodeJS. Ela fornece uma maneira de manipular dados binários brutos diretamente na memória, permitindo manipular arquivos binários ou fluxos de rede.
```node
const buffer = Buffer.from('Hello Node.js');
console.log(buffer);  // Outputs the binary representation
```
Saída
```
Buffer 48 65 6c 6c 6f 20 4e 6f 64 65 2e 6a 73>
```

### 5. `__dirname and __filename`
Estas são variáveis globais que representam o nome do diretório (`__dirname`) e o nome do arquivo (`__filename`) do módulo atual (file).
```node
console.log(__dirname);  // Outputs the directory of the current file
console.log(__filename); // Outputs the full path of the current file
```
Saída
```
/home/guest/sandbox 
/home/guest/sandbox/Solution.js
```

### 6. setTimeout() e setInterval()
Essas funções são usadas para agendar a execução do código. setTimeout() executa uma função após um atraso especificado, enquanto setInterval() executa uma função repetidamente em intervalos fixos.
```node
setTimeout(() => {
    console.log("This runs after 2 seconds");
}, 2000);

setInterval(() => {
    console.log("This runs every 3 seconds");
}, 3000);
```
Saída
![Captura de tela-2025-03-18-182925](https://media.geeksforgeeks.org/wp-content/uploads/20250318182957435864/Screenshot-2025-03-18-182925.png)

### 7. URL and URLSearchParams
URL é usado para manipular operações relacionadas a URL, e URLSearchParams ajuda a manipular parâmetros de consulta de URL.
```node
const myURL = new URL('https://www.example.com/?name=anjali');
console.log(myURL.searchParams.get('name'));  
myURL.searchParams.append('age', '30');
console.log(myURL.href);
```
Saída
```
anjali
https://www.example.com/?name=anjali&age=30
```

### 8. TextEncoder e TextDecoder
Essas classes são usadas para codificar e decodificar texto em diversas codificações, como UTF-8. Elas são úteis para trabalhar com dados de string que precisam ser convertidos para binário ou vice-versa.
```node
const encoder = new TextEncoder();
const encoded = encoder.encode("Hello, Node.js!");
console.log(encoded);  // Outputs a Uint8Array of encoded text
```
Saída
```
Uint8Array(15) [ 
   72, 101, 108, 108, 111, 
   44, 32, 78, 111, 100, 
  101, 46, 106, 115, 33 
]
```

### Por que os objetos globais são úteis?
Objetos globais em NodeJS são especialmente úteis porque permitem acessar funcionalidades comumente usadas sem a necessidade de importá-las de módulos externos. Por exemplo, em vez de exigir que um módulo interaja com o sistema de arquivos, você pode usar o objeto global fs para manipular arquivos e diretórios diretamente.

### Quando usar objetos globais no NodeJS?
Objetos globais são úteis em situações em que você precisa acessar funcionalidades comumente usadas em seu aplicativo. Eles são particularmente úteis para:

Gerenciando o processo: O objeto de processo dá acesso às informações relacionadas ao processo e ao ambiente.
```
Trabalhando com caminhos de arquivo: Os objetos __dirname e __filename ajudam a determinar a estrutura de diretório do seu aplicativo, o que é útil para manipular caminhos de arquivo relativos.
```
Temporizadores e intervalos: As funções setTimeout() e setInterval() são úteis para controlar o fluxo do seu aplicativo.
Manipulando dados binários: O objeto Buffer permite que você trabalhe com dados binários de forma eficiente.

### Quando NÃO usar objetos globais?
Embora objetos globais sejam convenientes, eles devem ser usados com cautela. Confiar demais em objetos globais pode tornar seu código mais difícil de testar e manter. Aqui estão alguns casos em que você deve evitar o uso excessivo de objetos globais:

Poluição de namespace: usar muitas variáveis globais pode causar conflitos de nomenclatura, dificultando o gerenciamento do seu código e aumentando o risco de bugs.
Dependências difíceis de rastrear: quando o código depende de muitas variáveis globais, fica mais difícil determinar onde certas variáveis estão sendo definidas ou modificadas, o que torna o código mais difícil de depurar e entender.
Desafios de teste: Código que depende muito de objetos globais pode ser difícil de simular ou criar stubs durante o teste.

### Conclusão
Objetos globais em NodeJS fornecem acesso a funcionalidades importantes, tornando seu processo de desenvolvimento mais eficiente e simplificado. Embora esses objetos sejam úteis para tarefas como manipulação de arquivos, gerenciamento de processos e interação com o ambiente, é importante usá-los com responsabilidade. O uso excessivo de objetos globais pode levar a um código mais difícil de manter e a dificuldades na depuração e nos testes.

