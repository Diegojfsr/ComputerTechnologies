O NodeJS foi projetado para ser single-threaded, mas fornece um módulo child_process para criar e gerenciar processos filhos. Isso permite executar comandos do sistema, outros scripts e executar tarefas computacionalmente custosas em paralelo. O módulo child process é essencial para tarefas como executar comandos de shell, gerar processos de trabalho e integrar-se com outros program

### O que é um processo filho?
Um processo filho é um processo separado criado e gerenciado pelo processo pai (seu aplicativo NodeJS). Isso permite que você execute comandos do sistema (como listar arquivos ou verificar o uso de memória).
Executar scripts (como Python, Bash ou outro script NodeJS)
Execute operações que exigem muita CPU sem bloquear o loop de eventos principal
Crie vários processos que sejam executados em paralelo (multithreading no NodeJS)

O módulo child_process no NodeJS fornece quatro métodos para criar processos filho:
spawn : inicia um novo processo com um comando fornecido. Ele transmite dados entre os processos pai e filho.
exec : executa um comando em um shell e armazena a saída em buffer. Útil para comandos de curta duração.
execFile : Semelhante ao exec, mas executa um arquivo executável específico diretamente, sem um shell.
fork : Um caso especial de spawn usado para criar processos filhos do NodeJS. Ele permite a comunicação entre processos pai e filho usando send e on('message').

### Métodos para criar processos filho

### 1. spawn() method
O método spawn() inicia um novo processo com um comando e argumentos especificados, fornecendo fluxos para entrada/saída. É ideal para lidar com saídas grandes ou processos de longa duração.
```node
const { spawn } = require('child_process');
const child = spawn('ls', ['-lh', '/usr']);

child.stdout.on('data', (data) => {
    console.log(`stdout: ${data}`);
});

child.stderr.on('data', (data) => {
    console.error(`stderr: ${data}`);
});

child.on('close', (code) => {
    console.log(`child process exited with code ${code}`);
});
```
Saída
![Processo-filho](https://media.geeksforgeeks.org/wp-content/uploads/20250227121455512515/Child-Process.png)
Neste exemplo
spawn('ls', ['-lh', '/usr']): Executa o comando ls com -lh e /usr como argumentos.
child.stdout.on('data', ...): Escuta dados da saída padrão.
child.stderr.on('data', ...): Escuta dados do erro padrão.
child.on('close', ...): Escuta o evento close, indicando que o processo foi concluído.

### 2. fork() method
O método fork() é um caso especial de spawn() usado especificamente para gerar novos processos NodeJS. Ele estabelece um canal IPC (Comunicação entre Processos) entre os processos pai e filho, permitindo que eles se comuniquem por meio de troca de mensagens.
```node
const { fork } = require('child_process');

const child = fork('child.js');

child.on('message', (message) => {
  console.log(`Message from child: ${message}`);
});

child.send('Hello from parent');
```
Saída
![Método Fork](https://media.geeksforgeeks.org/wp-content/uploads/20250227121906846813/Fork-methode.png)
Neste exemplo
f ork('child.js'): Gera um novo processo NodeJS executando o módulo child.js.
child.on('message', ...): Escuta mensagens do processo filho.
child.send('Olá do pai'): Envia uma mensagem ao processo filho.

### 3. exec() method
O método exec() executa um comando em um shell e armazena a saída em buffer, o que é adequado para comandos de curta duração com saídas pequenas.
```node
const { exec } = require('child_process');

// Counts the number of directory in
// current working directory
exec('dir | find /c /v ""', (error, stdout, stderr) => {
    if (error) {
        console.error(`exec error: ${error}`);
        return;
    }
    console.log(`stdout: No. of directories = ${stdout}`);
    if (stderr != "")
        console.error(`stderr: ${stderr}`);
});
```
Saída
![Método de execução](https://media.geeksforgeeks.org/wp-content/uploads/20250227122318311191/Execute-method.png)
Neste exemplo
exec('ls -lh /usr', ...): Executa o comando ls com -lh e /usr como argumentos.
O retorno de chamada recebe erro, stdout e stderr como parâmetros.
Registra a saída padrão e o erro no console.

### 4. execFile() method
O método execFile() executa um arquivo executável diretamente sem gerar um shell, tornando-o mais eficiente que exec() para executar binários e scripts diretamente.
```node
const { execFile } = require('child_process');

execFile('node', ['--version'], (error, stdout, stderr) => {
    if (error) {
        console.error(`execFile error: ${error}`);
        return;
    }
    console.log(`stdout: ${stdout}`);
    if (stderr) {
        console.error(`stderr: ${stderr}`);
    }
});
```
execFile('node', ['--version'], ...): Executa o binário NodeJS com o sinalizador --version.
O retorno de chamada recebe erro, stdout e stderr como parâmetros.
Registra a saída padrão e o erro no console.

### Comparação de exec, execFile, spawn e fork

|Método|Usar Shell?|Retorna a saída|Transmissão|Casos de uso|
|---|---|---|---|---|
|executar()|Sim|Saída de buffers|Não|Pequenos comandos de shell|
|execFile()|Não|Saída de buffers|Não|Executando arquivos binários|
|gerar()|Sim|Não (transmite em vez disso)|Sim|Manipulando grandes saídas|
|garfo()|Não|Utiliza passagem de mensagens|Sim|Executando processos NodeJS filhos|
### Melhores práticas para usar processos filho
Use exec() para comandos de shell simples (quando o tamanho da saída for pequeno).
Use execFile() para executar arquivos binários (mais rápido e seguro).
Use spawn() para manipular grandes volumes de dados ou streaming de saída em tempo real.
Use fork() para multiprocessamento e execução paralela no NodeJS.
Sempre trate os erros corretamente (use eventos stderr e error).
Use métodos assíncronos sempre que possível para evitar o bloqueio do loop de eventos.


